type KTT @entity {
  # id: The KTT's contract address
  id: ID!

  # Metadata when state was last changed
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!

  # The list of supported assets
  supportedAssets: [Asset!]! @derivedFrom(field: "supported")
  supportedAssetsForBonding: [Asset!]! @derivedFrom(field: "supportedForBonding")
  supportedAssetsForUnbonding: [Asset!]! @derivedFrom(field: "supportedForUnbonding")

  # Owner data
  owner: Bytes!
  pendingOwner: Bytes!

  # User data
  balances: [AccountBalance!]!
  approvals: [AccountApproval!]!
}

type Asset @entity {
  # id: The asset's contract address
  id: ID!

  # Metadata when state was last changed
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!

  # The price oracle of the asset
  oracle: Bytes! @derivedFrom(field: "asset")

  # lastPrice: BigInt! TODO: Treasury misses an event for that
  # Is set if asset is supported
  # TODO: This can be made cleaner (somehow)... Any DB expert here to normalize the schema?
  supported: KTT
  supportedForBonding: KTT
  supportedForUnbonding: KTT
}

type Oracle @entity {
  # id: The oracle's contract address
  id: ID!

  # Metadata when state was last changed
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!

  # Owner data
  owner: Bytes!
  pendingOwner: Bytes!

  # Metadata about settings
  isValid: Boolean!
  minimumProviders: BigInt!

  # The asset the oracle delivers the price of
  asset: Bytes!

  # The providers of the oracle
  providers: [Provider!]! @derivedFrom(field: "oracle")
}

type Provider @entity {
  # id: <provider address>-<oracle address>
  id: ID!

  # Metadata when state was last changed
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!

  # The oracle the provider is whitelisted for
  oracle: Oracle!

  # Data of the last report the provider pushed
  lastReportPayload: BigInt!
  lastReportTimestamp: BigInt!
}

type AccountBalance @entity {
  # id: The account address
  id: ID!

  # Metadata when state was last changed
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!

  # Balance data
  amount: BigInt!
}

type AccountApproval @entity {
  # id: <owner address>-<spender address>
  id: ID!

  # Metadata when state was last changed
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!

  # Approval data
  owner: Bytes!
  spender: Bytes!
  amount: BigInt!
  # Be careful with approvals. They can change without events emitted
  # by transfer{All}From calls.
}
